import "dotenv/config";
import express, { Request, Response } from "express";
import cors from "cors";
import helmet from "helmet";
import { rateLimit } from "express-rate-limit";
import * as path from "path";
import nodemailer from "nodemailer";

import OpenAI from "openai"; // npm i openai

import {
  generateApplicationPdfBuffer,
  dataUrlToPdfBuffer,
  mergePdfBuffersInOrder
} from "./pdfgen";

import {
  uploadMergedPdfToDrive,
  makeDriveFilePublicOrSkip,
  driveDirectDownloadUrl
} from "./cloudstorage";

import { sendWhatsAppNotification } from "./whatsapp";

const app = express();
app.set("trust proxy", 1);

// ---------- middleware ----------
app.use(helmet({ crossOriginResourcePolicy: false }));
app.use(cors());
app.use(express.json({ limit: "35mb" }));
app.use(rateLimit({ windowMs: 60 * 1000, max: 120, standardHeaders: true, legacyHeaders: false }));

// static logo etc
app.use("/public", express.static(path.join(__dirname, "public")));

// health must be OUTSIDE listen()
app.get("/api/health", (_req: Request, res: Response) => res.json({ ok: true }));

// ---------- in-memory storage ----------
type Submission = {
  appId: string;
  businessName: string;
  ownerName: string;
  createdAtISO: string;
  pdfBuffer: Buffer;
  drive?: any;
};
const submissions = new Map<string, Submission>();

// ---------- helpers ----------
export function safeText(v: unknown): string {
  return String(v ?? "").trim();
}

function nowISO(): string {
  return new Date().toISOString();
}

function makeAppId(): string {
  const d = new Date();
  const base = `${d.getFullYear()}${String(d.getMonth() + 1).padStart(2, "0")}${String(d.getDate()).padStart(2, "0")}`;
  let n = 0;
  for (const k of submissions.keys()) if (String(k).startsWith(base)) n++;
  return `${base}-${String(n + 1).padStart(4, "0")}`;
}

function buildMailer() {
  const host = process.env.SMTP_HOST || "smtp-relay.gmail.com";
  const port = Number(process.env.SMTP_PORT || 587);
  return nodemailer.createTransport({ host, port, secure: false, requireTLS: true });
}

/** Data URL -> Buffer (base64 portion) */
function safeB64ToBuffer(dataUrl: string | undefined): Buffer | null {
  if (!dataUrl) return null;
  try {
    const base64String = dataUrl.includes(",") ? dataUrl.split(",")[1] : dataUrl;
    return Buffer.from(base64String, "base64");
  } catch (err) {
    console.error("[utils] failed to parse base64:", err);
    return null;
  }
}

function normalizeISODate(val: string): string {
  if (!val) return "";
  const d = new Date(val);
  if (Number.isNaN(d.getTime())) return "";
  return d.toISOString().split("T")[0];
}

// ---------- OpenAI Vision Extractor ----------
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

type ExtractParams = {
  label: "id" | "check" | "w9";
  imageDataUrl: string;
  prompt: string;
};

/**
 * Extract JSON fields from an image using OpenAI.
 * We force a JSON object response.
 */
async function extractJsonFromImage(params: ExtractParams): Promise<Record<string, any>> {
  const { label, imageDataUrl, prompt } = params;

  // If you pass PDFs converted to PNG already, imageDataUrl is fine.
  // If it’s empty, bail.
  if (!imageDataUrl) return {};

  const resp = await openai.responses.create({
    model: process.env.OCR_MODEL || "gpt-4.1-mini",
    input: [
      {
        role: "user",
        content: [
          { type: "input_text", text: `${prompt}\nReturn ONLY valid JSON.` },
          { type: "input_image", image_url: imageDataUrl }
        ]
      }
    ],
    // best-effort JSON
    text: { format: { type: "json_object" } }
  });

  const outputText = resp.output_text || "";
  if (!outputText.trim()) {
    console.warn(`[extract:${label}] empty output_text`);
    return {};
  }

  try {
    return JSON.parse(outputText);
  } catch (e) {
    console.warn(`[extract:${label}] JSON parse failed, output_text first 300:\n`, outputText.slice(0, 300));
    return {};
  }
}

// ---------- routes ----------

/**
 * OCR prefill
 * Rules:
 * - 3 docs are mandatory always
 * - if consent=false => skip OCR but return success with empty extracted
 */
app.post("/api/extract", async (req: Request, res: Response) => {
  try {
    const { consent, idImageDataUrl, checkImageDataUrl, w9ImageDataUrl } = (req.body || {}) as {
      consent?: boolean;
      idImageDataUrl?: string;
      checkImageDataUrl?: string;
      w9ImageDataUrl?: string;
    };

    console.log("[extract] consent:", !!consent);

    // Mandatory 3 docs always
    if (!idImageDataUrl || !checkImageDataUrl || !w9ImageDataUrl) {
      return res.status(400).json({ success: false, error: "All 3 documents are required." });
    }

    if (!consent) {
      return res.json({ success: true, extracted: { id_fields: {}, bank_fields: {}, w9_fields: {} } });
    }

    // basic debug: show bytes
    const idBuf = safeB64ToBuffer(idImageDataUrl);
    const ckBuf = safeB64ToBuffer(checkImageDataUrl);
    const w9Buf = safeB64ToBuffer(w9ImageDataUrl);

    console.log("[extract] id bytes:", idBuf ? idBuf.length : 0);
    console.log("[extract] check bytes:", ckBuf ? ckBuf.length : 0);
    console.log("[extract] w9 bytes:", w9Buf ? w9Buf.length : 0);

    // prompts (keep these tight)
    const idPrompt =
      `You are extracting fields from a US driver's license or state ID.
Return JSON with keys:
first_name, middle_name, last_name, dob, id_number, id_expiration,
address_line, city, state, postal_code.
Dates should be YYYY-MM-DD when possible.`;

    const checkPrompt =
      `You are extracting bank fields from a voided check or bank letter.
Return JSON with keys: bank_name, routing_number, account_number.
routing_number and account_number should be digits only if possible.`;

    const w9Prompt =
      `You are extracting NON-SENSITIVE fields from IRS W-9.
DO NOT extract or return TIN/SSN/EIN.
Return JSON with keys: name, business_name, address_line, city, state, postal_code.`;

    const [id_raw, bank_raw, w9_raw] = await Promise.all([
      extractJsonFromImage({ label: "id", imageDataUrl: idImageDataUrl, prompt: idPrompt }),
      extractJsonFromImage({ label: "check", imageDataUrl: checkImageDataUrl, prompt: checkPrompt }),
      extractJsonFromImage({ label: "w9", imageDataUrl: w9ImageDataUrl, prompt: w9Prompt })
    ]);

    const id_fields = {
      first_name: safeText(id_raw.first_name),
      middle_name: safeText(id_raw.middle_name),
      last_name: safeText(id_raw.last_name),
      dob: normalizeISODate(safeText(id_raw.dob)),
      id_number: safeText(id_raw.id_number),
      id_expiration: normalizeISODate(safeText(id_raw.id_expiration)),
      address_line: safeText(id_raw.address_line),
      city: safeText(id_raw.city),
      state: safeText(id_raw.state),
      postal_code: safeText(id_raw.postal_code)
    };

    const bank_fields = {
      bank_name: safeText(bank_raw.bank_name),
      routing_number: safeText(bank_raw.routing_number).replace(/\D/g, ""),
      account_number: safeText(bank_raw.account_number).replace(/\D/g, "")
    };

    const w9_fields = {
      name: safeText(w9_raw.name),
      business_name: safeText(w9_raw.business_name),
      address_line: safeText(w9_raw.address_line),
      city: safeText(w9_raw.city),
      state: safeText(w9_raw.state),
      postal_code: safeText(w9_raw.postal_code)
    };

    console.log("[extract] done", {
      id_has_name: !!(id_fields.first_name || id_fields.last_name),
      bank_has_routing: !!bank_fields.routing_number,
      w9_has_name: !!(w9_fields.business_name || w9_fields.name)
    });

    return res.json({ success: true, extracted: { id_fields, bank_fields, w9_fields } });
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : "Extract failed";
    console.error("[extract] error:", msg);
    return res.status(500).json({ success: false, error: msg });
  }
});

app.post("/api/submit", async (req: Request, res: Response) => {
  try {
    const { formData, fileAttachments } = (req.body || {}) as any;
    if (!formData) return res.status(400).json({ success: false, error: "Missing formData" });

    // require 3 docs always
    const idFile = fileAttachments?.idFile;
    const checkFile = fileAttachments?.checkFile;
    const w9File = fileAttachments?.w9File;
    if (!idFile || !checkFile || !w9File) {
      return res.status(400).json({
        success: false,
        error: "All 3 documents are required: Photo ID, Voided Check/Letter, W-9."
      });
    }

    const appId = makeAppId();
    const createdAtISO = nowISO();

    // 1) application pdf
    const applicationPdfBuffer = await generateApplicationPdfBuffer(formData, appId);

    // 2) attachments -> pdf
    const idPdf = await dataUrlToPdfBuffer(idFile.dataUrl, idFile.mimeType || "");
    const checkPdf = await dataUrlToPdfBuffer(checkFile.dataUrl, checkFile.mimeType || "");
    const w9Pdf = await dataUrlToPdfBuffer(w9File.dataUrl, w9File.mimeType || "");

    // 3) merge order: application > id > check > w9
    const mergedPdfBuffer = await mergePdfBuffersInOrder([applicationPdfBuffer, idPdf, checkPdf, w9Pdf]);

    const businessName = safeText(formData.legalBusinessName);
    const ownerName = `${safeText(formData.ownerFirstName)} ${safeText(formData.ownerLastName)}`.trim();

    submissions.set(appId, {
      appId,
      businessName,
      ownerName,
      createdAtISO,
      pdfBuffer: mergedPdfBuffer
    });

    // 4) Drive upload optional
    let drive: any = null;
    try {
      drive = await uploadMergedPdfToDrive({ appId, mergedPdfBuffer });

      if (drive && !drive.skipped && drive.fileId && process.env.DRIVE_MAKE_PUBLIC === "true") {
        await makeDriveFilePublicOrSkip(drive.fileId);
        drive.directDownloadUrl = driveDirectDownloadUrl(drive.fileId);
      }
    } catch (e: unknown) {
      console.error("[drive] error:", e instanceof Error ? e.message : String(e));
    }

    if (drive && !drive.skipped) {
      const sub = submissions.get(appId)!;
      submissions.set(appId, { ...sub, drive });
    }

    // 5) email optional
    const toEmail = process.env.NOTIFY_EMAIL_TO || "";
    if (toEmail) {
      const transporter = buildMailer();
      await transporter.sendMail({
        from: process.env.EMAIL_FROM || "no-reply@halopayments.com",
        to: toEmail,
        subject: `New Merchant Application ${appId}`,
        text:
          `New application submitted.\n` +
          `App ID: ${appId}\n` +
          `Created: ${createdAtISO}\n` +
          `Business: ${businessName}\n` +
          `Owner: ${ownerName}`,
        attachments: [
          {
            filename: `${appId}-merged.pdf`,
            content: mergedPdfBuffer,
            contentType: "application/pdf"
          }
        ]
      });
    }

    // 6) WhatsApp optional
    const numbersCsv = process.env.WHATSAPP_NOTIFY_TO || "";
    const toNumbers = numbersCsv.split(",").map((s: string) => s.trim()).filter(Boolean);

    const waBody =
      `✅ New Merchant Application\n` +
      `AppId: ${appId}\n` +
      `Business: ${businessName || "-"}\n` +
      `Owner: ${ownerName || "-"}\n` +
      `Created: ${createdAtISO}`;

    const mediaUrl =
      submissions.get(appId)?.drive?.directDownloadUrl ||
      (process.env.PUBLIC_BASE_URL
        ? `${process.env.PUBLIC_BASE_URL}/api/submission/${encodeURIComponent(appId)}/pdf`
        : "");

    if (toNumbers.length) {
      try {
        await sendWhatsAppNotification({ toNumbers, body: waBody, mediaUrl: mediaUrl || undefined });
      } catch (e: unknown) {
        console.error("[whatsapp] error:", e instanceof Error ? e.message : String(e));
      }
    }

    return res.json({
      success: true,
      appId,
      businessName,
      ownerName,
      createdAt: createdAtISO
    });
  } catch (e: unknown) {
    console.error("[submit] error:", e);
    return res.status(500).json({ success: false, error: e instanceof Error ? e.message : "Submit failed" });
  }
});

app.get("/api/submission/:appId", (req: Request, res: Response) => {
  const appId = req.params.appId;
  const sub = submissions.get(appId);
  if (!sub) return res.status(404).json({ success: false, error: "Not found" });

  return res.json({
    success: true,
    appId: sub.appId,
    businessName: sub.businessName,
    ownerName: sub.ownerName,
    createdAt: sub.createdAtISO,
    driveLink: sub.drive?.webViewLink || "",
    driveDirectDownloadUrl: sub.drive?.directDownloadUrl || ""
  });
});

app.get("/api/submission/:appId/pdf", (req: Request, res: Response) => {
  const appId = req.params.appId;
  const sub = submissions.get(appId);
  if (!sub?.pdfBuffer) return res.status(404).send("Not found");

  res.setHeader("Content-Type", "application/pdf");
  res.setHeader("Content-Disposition", `attachment; filename="${appId}.pdf"`);
  return res.send(sub.pdfBuffer);
});

// ---------- start ----------
const PORT = Number(process.env.PORT || 4000);
app.listen(PORT, "0.0.0.0", () => {
  console.log(`✅ Server running at http://0.0.0.0:${PORT}`);
});
